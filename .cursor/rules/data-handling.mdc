
# Data Handling Requirements

## Database Query Helper Functions

**ALWAYS** use helper functions from the `db/queries` directory for all database operations. Never write raw database queries directly in server components or server actions.

### Directory Structure:
```
db/
  ├── queries/
  │   ├── users.ts
  │   ├── decks.ts
  │   ├── cards.ts
  │   └── index.ts
  ├── schema.ts
  └── index.ts
```

### Correct Pattern for Query Functions:
```tsx
// db/queries/users.ts
import { db } from '@/db';
import { users } from '@/db/schema';
import { eq } from 'drizzle-orm';

export async function getAllUsers() {
  return await db.query.users.findMany();
}

export async function getUserById(id: string) {
  return await db.query.users.findFirst({
    where: eq(users.id, id)
  });
}

export async function createUser(data: CreateUserInput) {
  return await db.insert(users).values(data);
}

export async function updateUser(id: string, data: UpdateUserInput) {
  return await db.update(users)
    .set(data)
    .where(eq(users.id, id));
}

export async function deleteUser(id: string) {
  return await db.delete(users).where(eq(users.id, id));
}
```

### Correct Pattern for Index File:
```tsx
// db/queries/index.ts
export * from './users';
export * from './decks';
export * from './cards';
```

## Server Components for Data Retrieval

**ALWAYS** use server components for data retrieval operations. Never fetch data directly in client components.

### Correct Pattern:
```tsx
// ✅ Good - Server Component using query helpers
import { getAllUsers } from '@/db/queries';

async function DataComponent() {
  const data = await getAllUsers();
  return <div>{/* render data */}</div>;
}
```

### Incorrect Pattern:
```tsx
// ❌ Bad - Client Component fetching data
'use client';
function DataComponent() {
  const [data, setData] = useState();
  useEffect(() => {
    fetch('/api/data').then(setData);
  }, []);
  return <div>{/* render data */}</div>;
}

// ❌ Bad - Direct database queries in components
async function DataComponent() {
  const data = await db.query.users.findMany(); // Don't do this
  return <div>{/* render data */}</div>;
}
```

## Server Actions for Database Operations

**ALWAYS** use server actions for any database mutations (insert, update, delete). Never use API routes for database operations.

### Correct Pattern:
```tsx
// ✅ Good - Server Action using query helpers
'use server';
import { z } from 'zod';
import { createUser } from '@/db/queries';

const CreateUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
});

export async function handleCreateUser(data: z.infer<typeof CreateUserSchema>) {
  const validatedData = CreateUserSchema.parse(data);
  return await createUser(validatedData);
}
```

### Usage in Client Component:
```tsx
'use client';
import { handleCreateUser } from './actions';

export function UserForm() {
  const handleSubmit = async (formData: FormData) => {
    const data = {
      name: formData.get('name') as string,
      email: formData.get('email') as string,
    };
    await handleCreateUser(data);
  };
  
  return <form action={handleSubmit}>{/* form fields */}</form>;
}
```

## Zod Validation Requirements

**ALWAYS** use Zod for data validation. Every server action must validate its input data with Zod.

### Required Pattern:
```tsx
'use server';
import { z } from 'zod';
import { updateUser } from '@/db/queries';

// ✅ Good - Define schema and type
const UserSchema = z.object({
  id: z.string().uuid(),
  name: z.string().min(1).max(100),
  email: z.string().email(),
  age: z.number().int().positive().optional(),
});

// ✅ Good - Extract TypeScript type from schema
type UserInput = z.infer<typeof UserSchema>;

export async function handleUpdateUser(data: UserInput) {
  // ✅ Good - Validate input data
  const validatedData = UserSchema.parse(data);
  
  // Use query helper function
  return await updateUser(validatedData.id, validatedData);
}
```

## TypeScript Type Requirements

**NEVER** use `FormData` as the type for server action parameters. Always define proper TypeScript types using Zod schemas.

### Incorrect Pattern:
```tsx
// ❌ Bad - Using FormData type
'use server';
export async function createUser(formData: FormData) {
  // Don't do this
}
```

### Correct Pattern:
```tsx
// ✅ Good - Using proper TypeScript types
'use server';
import { z } from 'zod';
import { createUser } from '@/db/queries';

const CreateUserSchema = z.object({
  name: z.string().min(1),
  email: z.string().email(),
});

type CreateUserInput = z.infer<typeof CreateUserSchema>;

export async function handleCreateUser(data: CreateUserInput) {
  const validatedData = CreateUserSchema.parse(data);
  return await createUser(validatedData);
}
```

## Complete Example

Here's a complete example showing all requirements:

```tsx
// lib/schemas/user.ts
import { z } from 'zod';

export const UserSchema = z.object({
  id: z.string().uuid().optional(),
  name: z.string().min(1, 'Name is required').max(100, 'Name too long'),
  email: z.string().email('Invalid email format'),
  age: z.number().int().positive().optional(),
});

export type User = z.infer<typeof UserSchema>;
export type CreateUserInput = Omit<User, 'id'>;
export type UpdateUserInput = User;

// db/queries/users.ts
import { db } from '@/db';
import { users } from '@/db/schema';
import { eq } from 'drizzle-orm';
import type { CreateUserInput, UpdateUserInput } from '@/lib/schemas/user';

export async function getAllUsers() {
  return await db.query.users.findMany();
}

export async function getUserById(id: string) {
  return await db.query.users.findFirst({
    where: eq(users.id, id)
  });
}

export async function createUser(data: CreateUserInput) {
  return await db.insert(users).values(data);
}

export async function updateUser(id: string, data: UpdateUserInput) {
  return await db.update(users)
    .set(data)
    .where(eq(users.id, id));
}

export async function deleteUser(id: string) {
  return await db.delete(users).where(eq(users.id, id));
}

// app/actions/user.ts
'use server';
import { z } from 'zod';
import { UserSchema, CreateUserInput, UpdateUserInput } from '@/lib/schemas/user';
import { createUser, updateUser, deleteUser } from '@/db/queries';

export async function handleCreateUser(data: CreateUserInput) {
  const validatedData = UserSchema.parse(data);
  return await createUser(validatedData);
}

export async function handleUpdateUser(data: UpdateUserInput) {
  const validatedData = UserSchema.parse(data);
  return await updateUser(validatedData.id!, validatedData);
}

export async function handleDeleteUser(id: string) {
  const validatedId = z.string().uuid().parse(id);
  return await deleteUser(validatedId);
}

// app/components/user-list.tsx
// ✅ Server Component for data retrieval using query helpers
import { getAllUsers } from '@/db/queries';

async function UserList() {
  const allUsers = await getAllUsers();
  
  return (
    <div>
      {allUsers.map(user => (
        <UserCard key={user.id} user={user} />
      ))}
    </div>
  );
}

// app/components/user-card.tsx
'use client';
import { handleUpdateUser, handleDeleteUser } from '@/app/actions/user';
import type { User } from '@/lib/schemas/user';

export function UserCard({ user }: { user: User }) {
  const handleUpdate = async (formData: FormData) => {
    const data = {
      id: user.id,
      name: formData.get('name') as string,
      email: formData.get('email') as string,
    };
    await handleUpdateUser(data);
  };
  
  const handleDelete = async () => {
    await handleDeleteUser(user.id);
  };
  
  return (
    <div>
      <form action={handleUpdate}>
        {/* form fields */}
      </form>
      <button onClick={handleDelete}>Delete</button>
    </div>
  );
}
```

## Key Points Summary

1. **Query Helpers**: Always use helper functions from `db/queries` directory
2. **Data Retrieval**: Always use server components with query helpers
3. **Database Mutations**: Always use server actions with query helpers
4. **Validation**: Always use Zod schemas
5. **TypeScript**: Always define proper types from Zod schemas
6. **Never use FormData as type**: Extract data and pass structured objects
7. **Validation**: Always validate input data in server actions before database operations
8. **Separation of Concerns**: Keep database logic in query helpers, validation in schemas, and business logic in server actions
